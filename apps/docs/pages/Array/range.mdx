import { Callout } from "nextra/components";
import REPL from "../../components/REPL";

> Generates a sequence of numbers starting at the `first` argument, progressing by the `step` argument, and stopping at the `second` argument.

<Callout emoji="âœ…" type="info">
It is based on the [Range proposal](https://tc39.es/proposal-iterator.range/) & [Iterator.range](https://github.com/tc39/proposal-iterator.range).
</Callout>

## Syntax

```ts
range(
  start: number,
  end: number,
  options?: number | { step: number; inclusive: false }
): number[]
```

<Callout type="info">
The `step` value can be auto infered based on the `start` & `end` values.
</Callout>

<Callout type="info">
The `third` argument can be either a `step` value or an `options` object.
</Callout>

## Usage

```ts
import { range } from '@opentf/std';

range(start, end);
```

## Examples

```ts
range() // It throws error

range(0) // It throws error

range(NaN, 0) // It throws error

range(0, 0) //=> []

range(0, 0, { inclusive: true }) //=> [0]

range(0, 5) //=> [0, 1, 2, 3, 4]

range(0, 5, { inclusive: true }) //=> [0, 1, 2, 3, 4, 5]

range(3, 9, { step: 3 }) //=> [3, 6]

range(0, -5) //=> [0, -1, -2, -3, -4]

range(0, -4, { step: -1 }) //=> [0, -1, -2, -3]

range(-10, -5) //=> [-10, -9, -8, -7, -6]

range(10, 12, { step: 0.5 }) //=> [10, 10.5, 11, 11.5]
```

## Try

<REPL code={`const { range } = require('@opentf/std');

log(range(1, 5));

for (const item of range(1, 5, {inclusive: true})) {
  log(item);
}
`} />