import { Callout } from "nextra/components";
import REPL from "../../components/REPL";

> Performs functions composition from right to left.

<Callout type="default">
  The `compose` function is equivalent to `a(b(c(val)))`.
</Callout>

**Related**

- [composeFn](/Function/composeFn)
- [aCompose](/Async/aCompose)
- [aComposeFn](/Async/aComposeFn)
- [pipe](/Function/pipe)
- [pipeFn](/Function/pipeFn)
- [aPipe](/Async/aPipe)
- [aPipeFn](/Async/aPipeFn)

## Syntax

```ts
import { compose } from '@opentf/std';

compose(val: unknown, ...fns: Function[]): unknown
```

## Examples

```ts
compose(1); //=> 1

compose(-1, Math.abs); //=> 1

compose(-4, Math.sqrt, Math.abs); //=> 2

compose(
  1.5,
  Math.ceil,
  (x) => x + 1,
  (x) => x * 5
); //=> 9
```

## Try

<REPL code={`const { compose } = require('@opentf/std');

compose(1.5, Math.ceil, (x) => x + 1, (x) => x \* 5);
`} />

## Learn

Why we need function composition?

- The deep nesting of functions is hard to read.
- It eliminates temporary variables.
- Method chaining is limited, for Eg: await, yeild, etc.

### Resources

- [tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)

- [Hack Pipe Operator](https://docs.hhvm.com/hack/expressions-and-operators/pipe)
